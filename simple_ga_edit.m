function [param_vals,best_chisq,current_par_vals,chi_values,saved_chisq,saved_pars,RMSD,indvar1_sim,simvals]=simple_ga_edit(params,generations,pop_size,data,weights,crossover,stdevs,best,mut_probability,cross_probability,elite,decay,nlls_size,time,ntp);

%%%% This is a simple genetic algorithm that was written to allow grid
%%%% search calculations.  It is written in pretty general terms and can
%%%% therefor be customized to any fitting application relatively easily By
%%%% editing the residual calculator.  As written, the search is bounded.  The algorithm works more or less like any other
%%%% GA.  At each round a new population is generated.  Some of these
%%%% individuals are generated by crossover, some by mutation, and some are
%%%% elite (they pass unaltered from the previous generation).  At each
%%%% generation (after chisq is calculated) the chisq values are ranked.
%%%% Out of this ranking an elite population is chosen.  In addition to the
%%%% elite population, a "best" population is chosen.  Half of the
%%%% crossover-generated next generation and half of the mutation-generated
%%%% next generation are produced from this best population.  What this
%%%% means is that half of the crossover fraction is satisfied by crossovers
%%%% based only on this best population and half of the mutation fraction
%%%% is satisfied by mutation made only on this best population.  The
%%%% other halves of these two fractions are produced by crossover or
%%%% mutations generated using the rest (non-best) of the population.  It
%%%% is important to note here that due to the bounded nature of the global
%%%% search, the mutation function is not truely gaussian.
%%%% The inputs are as follows -


%%%% params - initial guesses - The initial population matrix is generated
%%%% by adding a value taken randomly from a gaussian distribution with a
%%%% mean of zero and a standard deviation equal to the parameter value (as
%%%% written; may change this to the inpute stdev).

%%%% generations - this is the number of GA generations

%%%% pop_size - this is the size of the population (number of individuals)

%%%% data - this is the experimental data.  This is was chisq will be
%%%% calculated from

%%%% weights - these are the weights of the experimental data.  The will be
%%%% used to weights the residuals during calculation of Chisq.

%%%% crossover - this is the fraction of individuals during each run that
%%%% are generated by crossing over (Vs. mutation).

%%%% stdevs - these are the standard deviations defining the normal
%%%% distribution from which random values are drawn when individuals are
%%%% generated by mutation.  The mean of these distributions are zero.
%%%% Note that the standard deviation is fractional - ie. a value of 1
%%%% means that stnadard deviation is 100% of param value.  Look at the
%%%% loops that create the mutation fraction and the use of the
%%%% "shrink_val".

%%%% best - this is the number of individuals that are used to generate
%%%% the "best" population that is discussed in the introduction.

%%%% mut_probability - this number defines the probability that a parameter
%%%% value within an individual will be mutated.  When individuals are
%%%% being produced by mutation, the probability that the value of parameter (n) of a
%%%% specific individual will be produced by mutation is mut_probability.  The corrolary
%%%% is that the probability that the value of parameter (n) of a specific
%%%% individual running through the mutation process
%%%% will reach the next generation un-altered is 1-mut_probability.

%%%% cross_probability - this number defines the probability that a
%%%% parameter value within an individual will be subjected to a crossover
%%%% event.  When individuals are being produced by crossing over, the
%%%% probability that the value of parameter (n) of a specific individual will be
%%%% produced by a crossover event is cross_probability.  The corrolary is
%%%% that the probability that the value of parameter (n) of a specific
%%%% individual running through the crossover process will reach the next
%%%% generation un-altered is 1-cross_probability.

%%%% elite - this is the number of individuals that advance to the next
%%%% generation unaltered.  The individuals are chosen by ranking the Chisq
%%%% values.  The individuals that advance are the top (n) where the value
%%%% of "n" is defined by the elite field.  The way the algorithm is
%%%% written, elite must be less than or equal to best.

%%%% decay - this controls the rate of change of the standard deviations
%%%% used during mutation.  The standard deviation changes according to the
%%%% reciprocal of the generation number according to stdev(generationN)=stdev(generation1)*abs((1-decay*(generationN/generationT))) where
%%% generation"N" refers to the generation number and generation"T" refers
%%% to the total number of generations.  Depending on the value of decay
%%% the standard deviation changes in different ways.  For decay of zero,
%%% standard deviation is constant.  For decay of one, standard deviation
%%% shrinks from the initial standard deviation to zero at a rate of
%%% 1/generation.  For a decay between 1 and generations, the standard
%%% deviation shrinks at a rate dictated by decay until decay equals the
%%% generation number then grows.  For decay values larger than generations
%%% the standard deviation grows throughout the run.


%%% Time points of data set.
%time=[0.005 0.007 0.01 0.02 0.03 0.04 0.05 0.1 0.2 0.3 0.4 0.5 1 2 6 10];
indvar1_sim=linspace(min(time),max(time),1e4);

%%% Initial substrate concentrations (or whatever the higher dimension
%%% variable).
%ntp=[10e-6;20e-6;50e-6;100e-6;300e-6;500e-6;1e-3;2e-3];

%%% Pre-allocated matrices for the population matrix, the "best population"
%%% matrix, and the Chi-square matrix (N X 1 matrix).
population_mat=zeros(pop_size,length(params));
best_pop=zeros(best,length(params));
chisq=population_mat(1:end,1);

%%% Pre-alloacted matrix for the saved parameters and chisq values.
saved_pars=zeros(generations*pop_size,length(params));
saved_chisq=saved_pars(1:end,1);

%%% These lines set up parlim.  These variables will be used
%%% during opimization by nlls.  It appears that non-zero lower limits must
%%% be used to avoid integration issues.  Other non-zero limits can be
%%% imposed here.  Note that limits are imposed during population
%%% generation during each GA cycle.
parlim=[ones(length(params),1) zeros(length(params),1) ones(length(params),1) [Inf*ones(1,17)']];
%parlim(8:10,4)=1;

%%% These lines generate sub-matricies for the mutation and crossover
%%% population and the elite and nlls populations.  This will ensure that
%%% the mutation and crossover fractions are preserved.
if nlls_size>0
mut_cross_size=pop_size-(elite+nlls_size+1);
else mut_cross_size=pop_size-elite;
end
if nlls_size>0
elite_and_nlls_mat=zeros(elite+nlls_size+1,length(params));
else
    elite_and_nlls_mat=zeros(elite,length(params));
end
mut_cross_mat=zeros(mut_cross_size,length(params));

current_par_vals=zeros(pop_size,generations);
chi_values=ones(pop_size,generations);

%%% This is the initial production of a randomized population.  All
%%% individuals are produced by a mutation event in which a random value
%%% drawn from a gaussian distribution (mean=0, stdev=initial guess
%%% parameter value) is added to every parameter of every individual.
%%% After this saturating mutation event, a single individual from the
%%% population matrix is replaced by the initial guess individual.
for i=1:length(params)
parfor j=1:pop_size
population_mat(j,i)=normrnd(0,abs(params(i)));
end
end
population_mat(1,1:end)=params;

counter=1;
running_dev=zeros(generations,length(params));
running_pars=running_dev;
%%% This is the beginning of the main loop that will be executed the number
%%% of times dictated by generations.  At every execution of the loop the
%%% standard deviation shrinks accroding to
%%% stdev(generationN)=stdev(generation1)*(1-decay*(generationN/generationT)) where
%%% generation"N" refers to the generation number and generation"T" refers
%%% to the total number of generations.  At the last generation stdev=0.
for g=1:generations
    shrink_vals=stdevs.*abs((1-(decay*(g/generations))));
    display(g)
  
    
    
%%% The following two loops impose the bounds on each parameter value.
%%% Strictly speaking bounds are unnecessary but if the parameters are
%%% going to be passed to a numerical integration algorithm the bounds are
%%% critical to prevent ill-conditioned matricies in the numerical
%%% integration algorithm.

    
    for k=1:pop_size
        for j=1:length(params)
            if population_mat(k,j)<=1e-9
                population_mat(k,j)=1e-9;
            else population_mat(k,j)=population_mat(k,j);
            end
        end
    end
    for k=1:pop_size
        for j=1:length(params)
            if population_mat(k,j)>=1e8
                population_mat(k,j)=1e8;
            else population_mat(k,j)=population_mat(k,j);
            end
        end
    end
% 
%      for k=1:pop_size
%          for i=28:36
%         if population_mat(k,i)>=1
%             population_mat(k,i)=1;
%         else population_mat(k,i)=population_mat(k,i);
%         end
%          end
%     end
    for k=1:pop_size
        if population_mat(k,17)>=1
            population_mat(k,17)=1;
        else population_mat(k,17)=population_mat(k,17);
        end
    end
    
    for k=1:pop_size
            population_mat(k,1)=1E8;
            population_mat(k,4)=0;
   end
    
for k=1:pop_size
        if population_mat(k,5)<=25
            population_mat(k,5)=25;
        else population_mat(k,5)=population_mat(k,5);
        end
end
    
% for k=1:pop_size
%         if population_mat(k,13)<=300
%             population_mat(k,13)=300;
%         else population_mat(k,13)=population_mat(k,13);
%         end
%     end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% This loop imposes a bound on a single parameter.  Unblock to use it.
%{
    for k=1:pop_size
        if population_mat(k,8)>=1
            population_mat(k,8)=1;
        else population_mat(k,8)=population_mat(k,8);
        end
    end
    for k=1:pop_size
        if population_mat(k,9)>=1
            population_mat(k,9)=1;
        else population_mat(k,9)=population_mat(k,9);
        end
    end
        for k=1:pop_size
        if population_mat(k,10)>=1
            population_mat(k,10)=1;
        else population_mat(k,10)=population_mat(k,10);
        end
        end
    for k=1:pop_size
        if population_mat(k,21)>=1
            population_mat(k,21)=1;
        else population_mat(k,21)=population_mat(k,21);
        end
    end

%}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%% Chisq values are calculated in parallel in the following parfor loop.
%%% Make sure to enter the correct function in the "data-" field.  This
%%% function should output simulated data generated with input parameter
%%% values.


parfor q=1:pop_size
    %pop_mat=population_mat;
    chisq(q,1)=sum(sum(((data-model_simulator(population_mat(q,1:end)',time,ntp))./weights).^2)); 
end

%%% pop_mat is generated for use downstream.  pop_mat is equal to the
%%% population matrix from the generation that was just used to calculate
%%% Chisq values.  Chisq values are sorted (ascending order) and two vectors are generated
%%% based on this sorting process.  One vector (Y) is the sorted Chisq
%%% values, the other vector (index) is a vector listing the positions of
%%% the original Chisq vector.  For example, the lowest Chisq value will be
%%% element (1) of Y but may have been element (10) of Chisq.  Index
%%% element (1) will be a 10.  Index reports on the coordinates of the
%%% sorted Chisq values
pop_mat=population_mat;
[Y,index]=sort(chisq);

%%% These next two lines save the parameters and chisq values at each generation for further
%%% statistical analyses.
saved_pars((g*pop_size-pop_size+1):(g*pop_size),(1:length(population_mat(1,1:end))))=pop_mat;
saved_chisq((g*pop_size-pop_size+1):(g*pop_size),1)=chisq;

%%% This loop produces the "best" population.  The number of individuals in
%%% the best population is defined in the input in the "elite" field.
for m=1:best
best_pop(m,1:end)=population_mat(index(m),1:end);
end


if nlls_size>0
number_best_nlls=round((1/counter)*nlls_size);
if number_best_nlls==0
    number_best_nlls=1;
end
if number_best_nlls==nlls_size
    number_best_nlls=number_best_nlls-1;
end
number_rand_nlls=nlls_size-number_best_nlls;

NLLS_pop=zeros(nlls_size,length(params));


%%% This next block generates the "NLLS Pop".  In the parfor loop the top
%%% of the best population is further optimized by NLLS.  The number of
%%% individuals to be optimized is specified by the "nlls_size" field in
%%% the input.  After this parfor loop a random individual is chosen from
%%% the entire population matrix and optimized by NLLS.
parfor r=1:number_best_nlls
    loop_lim=parlim;
pars=best_pop(r,1:end)';
loop_lim(1,3)=pars(1);
loop_lim(2,3)=pars(2);
loop_lim(3,3)=pars(3);
loop_lim(4,3)=pars(4);
loop_lim(5,3)=pars(5);
loop_lim(6,3)=pars(6);
loop_lim(7,3)=pars(7);
loop_lim(8,3)=pars(8);
loop_lim(9,3)=pars(9);
loop_lim(10,3)=pars(10);
loop_lim(11,3)=pars(11);
loop_lim(12,3)=pars(12);
loop_lim(13,3)=pars(13);
loop_lim(14,3)=pars(14);
loop_lim(15,3)=pars(15);
loop_lim(16,3)=pars(16);
loop_lim(17,3)=pars(17);
%{
loop_lim(18,3)=pars(18);
loop_lim(19,3)=pars(19);
loop_lim(20,3)=pars(20);
loop_lim(21,3)=pars(21);
loop_lim(22,3)=pars(22);
loop_lim(23,3)=pars(23);
loop_lim(24,3)=pars(24);
loop_lim(25,3)=pars(25);
loop_lim(26,3)=pars(26);
loop_lim(27,3)=pars(27);
loop_lim(28,3)=pars(28);
loop_lim(29,3)=pars(29);
loop_lim(30,3)=pars(30);
loop_lim(31,3)=pars(31);
loop_lim(32,3)=pars(32);
loop_lim(33,3)=pars(33);
loop_lim(34,3)=pars(34);
loop_lim(35,3)=pars(35);
loop_lim(36,3)=pars(36);
loop_lim(37,3)=pars(37);
loop_lim(38,3)=pars(38);
loop_lim(39,3)=pars(39);
loop_lim(40,3)=pars(40);
loop_lim(41,3)=pars(41);
loop_lim(42,3)=pars(42);
loop_lim(43,3)=pars(43);
loop_lim(44,3)=pars(44);
loop_lim(45,3)=pars(45);
loop_lim(46,3)=pars(46);
loop_lim(47,3)=pars(47);
loop_lim(48,3)=pars(48);
loop_lim(49,3)=pars(49);
loop_lim(50,3)=pars(50);
loop_lim(51,3)=pars(51);
loop_lim(52,3)=pars(52);
loop_lim(53,3)=pars(53);
loop_lim(54,3)=pars(54);
loop_lim(55,3)=pars(55);
loop_lim(56,3)=pars(56);
%}


[fit_parlim, residual, resnorm,~]=exp_fit(time,data,loop_lim,weights,ntp);
par1(r,1)=fit_parlim(1,3);
par2(r,1)=fit_parlim(2,3);
par3(r,1)=fit_parlim(3,3);
par4(r,1)=fit_parlim(4,3);
par5(r,1)=fit_parlim(5,3);
par6(r,1)=fit_parlim(6,3);
par7(r,1)=fit_parlim(7,3);
par8(r,1)=fit_parlim(8,3);
par9(r,1)=fit_parlim(9,3);
par10(r,1)=fit_parlim(10,3);
par11(r,1)=fit_parlim(11,3);
par12(r,1)=fit_parlim(12,3);
par13(r,1)=fit_parlim(13,3);
par14(r,1)=fit_parlim(14,3);
par15(r,1)=fit_parlim(15,3);
par16(r,1)=fit_parlim(16,3);
par17(r,1)=fit_parlim(17,3);
%{
par18(r,1)=fit_parlim(18,3);
par19(r,1)=fit_parlim(19,3);
par20(r,1)=fit_parlim(20,3);
par21(r,1)=fit_parlim(21,3);
par22(r,1)=fit_parlim(22,3);
par23(r,1)=fit_parlim(23,3);
par24(r,1)=fit_parlim(24,3);
par25(r,1)=fit_parlim(25,3);
par26(r,1)=fit_parlim(26,3);
par27(r,1)=fit_parlim(27,3);
par28(r,1)=fit_parlim(28,3);
par29(r,1)=fit_parlim(29,3);
par30(r,1)=fit_parlim(30,3);
par31(r,1)=fit_parlim(31,3);
par32(r,1)=fit_parlim(32,3);
par33(r,1)=fit_parlim(33,3);
par34(r,1)=fit_parlim(34,3);
par35(r,1)=fit_parlim(35,3);
par36(r,1)=fit_parlim(36,3);
par37(r,1)=fit_parlim(37,3);
par38(r,1)=fit_parlim(38,3);
par39(r,1)=fit_parlim(39,3);
par40(r,1)=fit_parlim(40,3);
par41(r,1)=fit_parlim(41,3);
par42(r,1)=fit_parlim(42,3);
par43(r,1)=fit_parlim(43,3);
par44(r,1)=fit_parlim(44,3);
par45(r,1)=fit_parlim(45,3);
par46(r,1)=fit_parlim(46,3);
par47(r,1)=fit_parlim(47,3);
par48(r,1)=fit_parlim(48,3);
par49(r,1)=fit_parlim(49,3);
par50(r,1)=fit_parlim(50,3);
par51(r,1)=fit_parlim(51,3);
par52(r,1)=fit_parlim(52,3);
par53(r,1)=fit_parlim(53,3);
par54(r,1)=fit_parlim(54,3);
par55(r,1)=fit_parlim(55,3);
par56(r,1)=fit_parlim(56,3);
%}


end
NLLS_pop(1:number_best_nlls,1:end)=[par1 par2 par3 par4 par5 par6 par7 par8 par9 par10 par11 par12 par13 par14 par15 par16 par17];
parfor r=1:number_rand_nlls
rand_pars=population_mat(randi(pop_size),1:end);
rand_parlim=parlim;
rand_parlim(1:end,3)=rand_pars';
[rand_fitpars, residual, resnorm,~]=exp_fit(time,data,rand_parlim,weights,ntp);
rpar1(r,1)=rand_fitpars(1,3);
rpar2(r,1)=rand_fitpars(2,3);
rpar3(r,1)=rand_fitpars(3,3);
rpar4(r,1)=rand_fitpars(4,3);
rpar5(r,1)=rand_fitpars(5,3);
rpar6(r,1)=rand_fitpars(6,3);
rpar7(r,1)=rand_fitpars(7,3);
rpar8(r,1)=rand_fitpars(8,3);
rpar9(r,1)=rand_fitpars(9,3);
rpar10(r,1)=rand_fitpars(10,3);
rpar11(r,1)=rand_fitpars(11,3);
rpar12(r,1)=rand_fitpars(12,3);
rpar13(r,1)=rand_fitpars(13,3);
rpar14(r,1)=rand_fitpars(14,3);
rpar15(r,1)=rand_fitpars(15,3);
rpar16(r,1)=rand_fitpars(16,3);
rpar17(r,1)=rand_fitpars(17,3);
%{
rpar18(r,1)=rand_fitpars(18,3);
rpar19(r,1)=rand_fitpars(19,3);
rpar20(r,1)=rand_fitpars(20,3);
rpar21(r,1)=rand_fitpars(21,3);
rpar22(r,1)=rand_fitpars(22,3);
rpar23(r,1)=rand_fitpars(23,3);
rpar24(r,1)=rand_fitpars(24,3);
rpar25(r,1)=rand_fitpars(25,3);
rpar26(r,1)=rand_fitpars(26,3);
rpar27(r,1)=rand_fitpars(27,3);
%}
end
rand_NLLS=[rpar1 rpar2 rpar3 rpar4 rpar5 rpar6 rpar7 rpar8 rpar9 rpar10 rpar11 rpar12 rpar13 rpar14 rpar15 rpar16 rpar17];
NLLS_pop(number_best_nlls+1:nlls_size,1:end)=rand_NLLS;

end
clear par1 par2 par3 par4 par5 par6 par7 par8 par9 par10 par11 par12 par13 par14 par15 par16 par17
clear rpar1 rpar2 rpar3 rpar4 rpar5 rpar6 rpar7 rpar8 rpar9 rpar10 rpar11 rpar12 rpar13 rpar14 rpar15 rpar16 rpar17 
%%% This loop generates the half of the crossover fraction that is
%%% generated from the best population.
for n=1:round(mut_cross_size*crossover*0.5)
    rand_coordinate=randi(best);
    for j=1:length(params);
        rand_num=rand();
        if rand_num<=cross_probability
        mut_cross_mat(n,j)=best_pop(randi(best),j);
        else mut_cross_mat(n,j)=best_pop(rand_coordinate,j);
        end
    end
end

%%% This loop generates the half of the crossover fraction that is
%%% generated from the general population.
for n=round(mut_cross_size*crossover*0.5):round(mut_cross_size*crossover)
    rand_coordinate=randi(pop_size);
    for j=1:length(params)
        rand_num=rand();
        if rand_num<=cross_probability
        mut_cross_mat(n,j)=pop_mat(randi(pop_size),j);
        else mut_cross_mat(n,j)=pop_mat(rand_coordinate,j);
        end
    end
end

%%% This loop generates the half of the mutation fraction that is
%%% generated from the best population.
for r=round(mut_cross_size*crossover):round(length(mut_cross_mat(1:end,1))*0.75)
    rand_coordinate=randi(best);
for j=1:length(params)
    rand_num=rand();
    if rand_num<=mut_probability
    mut_cross_mat(r,j)=normrnd(0,abs(best_pop(rand_coordinate,j))*shrink_vals(j));
    else mut_cross_mat(r,j)=best_pop(rand_coordinate,j);
    end
end
end

%%% This loop generates the half of the mutation fraction that is generated
%%% from the general population.
for r=round(length(mut_cross_mat(1:end,1))*0.75):mut_cross_size
    rand_coordinate=randi(pop_size);
    for j=1:length(params)
        rand_num=rand();
        if rand_num<=mut_probability
        mut_cross_mat(r,j)=normrnd(0,abs(pop_mat(rand_coordinate,j))*shrink_vals(j));
        else mut_cross_mat(r,j)=pop_mat(rand_coordinate,j);
        end
    end
end

%%% This step generates the elite individuals and places them into the
%%% population matrix.
if nlls_size>0
elite_and_nlls_mat(1:elite,1:end)=best_pop(1:elite,1:end);

%%% This step introduces the sub-population that was further opimized by
%%% NLLS back into the general population.
elite_and_nlls_mat(elite+1:nlls_size+elite,1:end)=NLLS_pop;
else
    elite_and_nlls_mat(1:end,1:end)=best_pop(1:elite,1:end);
end
%%% This step combines the elite, nlls, mutation, and crossover populations
population_mat(1:pop_size-mut_cross_size,1:end)=elite_and_nlls_mat;
population_mat(pop_size-mut_cross_size+1:pop_size,1:end)=mut_cross_mat;

%%% This generates a running plot of chisq values Vs. generation number.
fig1 = figure(1);
subplot(2,2,1)
running_chi(g,1)=Y(1);
x_ax=[1:1:g];
semilogy(x_ax,running_chi)
    xlabel('Cycle Number');
ylabel('Chi-Square');
title('Chi-Square');
set(gca,'fontsize',20,'linewidth',2);


subplot(2,2,2)
running_mean(g,1)=mean(running_dev(g,1:end));
plot(x_ax,running_mean)
xlabel('Cycle Number');
ylabel('Stdev');
title('Mean Parameter Stdev');
set(gca,'fontsize',20,'linewidth',2);

subplot(2,2,3)
running_pars(g,1:end)=best_pop(1,1:end);
semilogy(x_ax,running_pars(1:g,1:end))
xlabel('Cycle Number');
ylabel('Parameter Value');
title('Best Fit Params');
set(gca,'fontsize',20,'linewidth',2);
    drawnow
    display(Y(1))

current_par_vals(1:end,g)=population_mat(1:end,1);
chi_values(1:end,g)=Y;

%%

fig2 = figure(2);

subplot(2,2,1)
sim_data = model_simulator(population_mat(1,1:end)',indvar1_sim,ntp);

semilogx(time,data(:,1:3:end),'o',indvar1_sim,sim_data(:,1:3:end)); 
xlabel('time (s)')
ylabel('Fraction of RNA')
% axis([1 5 1e-3 15])
set(gca,'fontsize',20,'linewidth',2);
title('11mer');

subplot(2,2,2)
semilogx(time,data(:,2:3:end),'o',indvar1_sim,sim_data(:,2:3:end)); 
xlabel('time (s)')
ylabel('Fraction of RNA')
% axis([1 5 1e-3 15])
set(gca,'fontsize',20,'linewidth',2);
title('12mer');

subplot(2,2,3)
semilogx(time,data(:,3:3:end),'o',indvar1_sim,sim_data(:,3:3:end)); 
xlabel('time (s)')
ylabel('Fraction of RNA')
% axis([1 5 1e-3 15])
set(gca,'fontsize',20,'linewidth',2);
title('CA');




    
    

%%% This reports the best Chisq value and the best fit parameter values.
best_chisq=Y(1);
param_vals=best_pop(1,1:end);
residual=data-model_simulator(param_vals',time,ntp);
RMSD=sqrt(sum(sum(residual.^2))/numel(data));
simvals=model_simulator(param_vals',indvar1_sim,ntp);
%export=[indvar1_sim simvals];


% saveas(fig1,sprintf('RunFig'));

if g>=2
    grad=chi_values(g,end)/chi_values(g,end-1);
else grad=0.8;
end
if grad>0.9
    counter=counter+1;
else counter=1;
end


end 
end 

